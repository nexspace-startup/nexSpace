// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Presence / availability states for users
enum PresenceStatus {
  AVAILABLE
  BUSY
  IN_MEETING
  AWAY
  DO_NOT_DISTURB
}

enum AuthProvider {
  local
  google
  microsoft
}

model User {
  id          BigInt  @id @default(autoincrement())
  first_name  String  @db.VarChar(100)
  last_name   String  @db.VarChar(100)
  displayName String? @db.VarChar(120)

  // canonical email (case-insensitive at DB level with CITEXT)
  email           String    @unique @db.Citext
  emailVerifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lastSeen  DateTime? @default(now())

  // relations
  identities        AuthIdentity[]
  credential        UserLogin?
  workspacesCreated Workspace[]       @relation("UserCreatedWorkspaces")
  memberships       WorkspaceMember[]
  invitesSent       Invitation[]      @relation("UserInvites")

  // Chat relations (named -> must have both sides!)
  chatMessages     ChatMessage[] @relation("ChatMessageSender")
  receivedMessages ChatMessage[] @relation("ChatMessageRecipient")

  // Thread read relations (named -> must have both sides!)
  chatThreadRead   ChatThreadRead[] @relation("ChatThreadReadReader")
  chatThreadAsPeer ChatThreadRead[] @relation("ChatThreadReadPeer")

  // Presence relations
  status    UserStatus?
  presences UserPresence[]
  sessions  UserWorkspaceSession[]
  
  @@index([email])
  @@index([lastSeen(sort: Desc)])
  //@@map("public.User")
}

model AuthIdentity {
  id          BigInt       @id @default(autoincrement())
  userId      BigInt
  provider    AuthProvider
  providerId  String // email for local login and sub for google/microsoft
  createdAt   DateTime     @default(now())
  lastLoginAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([provider, providerId])
  @@index([userId, provider])
}

model UserLogin {
  userId    BigInt   @id
  hash      String   @db.VarChar(255)
  alg       String   @default("argon2id")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
}

model Workspace {
  uid       String   @id @default(cuid())
  name      String   @db.VarChar(120)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById BigInt
  createdBy   User   @relation("UserCreatedWorkspaces", fields: [createdById], references: [id], onDelete: Restrict, onUpdate: Cascade)

  members        WorkspaceMember[]
  invitations    Invitation[]
  chatMessages   ChatMessage[]
  chatThreadRead ChatThreadRead[]

  // presence/analytics relations
  presences UserPresence[]
  sessions  UserWorkspaceSession[]

  @@index([createdById])
  //@@map("public.Workspace")
}

model WorkspaceMember {
  workspaceUid String
  userId       BigInt

  role     WorkspaceRole @default(MEMBER)
  joinedAt DateTime      @default(now())

  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([workspaceUid, userId])
  @@index([userId])
  @@index([workspaceUid, role])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REVOKED
  EXPIRED
}

model Invitation {
  id           String           @id @default(uuid()) @db.Uuid
  workspaceUid String
  invitedBy    BigInt
  invitedEmail String           @db.Citext
  role         WorkspaceRole    @default(MEMBER)
  expiresAt    DateTime
  status       InvitationStatus @default(PENDING)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)
  inviter   User      @relation("UserInvites", fields: [invitedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([workspaceUid])
  @@index([invitedEmail])
}

// Email templates
model EmailTemplate {
  id        String   @id @default(uuid())
  name      String   @unique
  subject   String
  mailBody  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Chat messages (per workspace/room)
model ChatMessage {
  id           BigInt    @id @default(autoincrement())
  workspaceUid String
  senderId     BigInt
  /// when set, message is a private DM visible only to sender and this recipient
  recipientId  BigInt?
  /// LiveKit room id (can equal Workspace.uid)
  roomUid      String
  content      String
  createdAt    DateTime  @default(now())
  deletedAt    DateTime?

  // relations
  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)
  sender    User      @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  recipient User?     @relation("ChatMessageRecipient", fields: [recipientId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // indexes tuned for unread counts + typical inbox queries
  @@index([workspaceUid, createdAt])
  @@index([senderId, createdAt])
  @@index([workspaceUid, recipientId, createdAt]) // fetch my DMs by recency
  @@index([workspaceUid, recipientId, senderId, createdAt]) // unread groupBy(senderId) with cutoff
  @@index([workspaceUid, senderId, deletedAt]) // soft-deletion-aware scans
}

// Per-user DM read state for each peer inside a workspace
model ChatThreadRead {
  workspaceUid String
  userId       BigInt
  peerId       BigInt
  lastReadAt   DateTime @default(now())
  updatedAt    DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)

  // Reader (me)
  user User @relation("ChatThreadReadReader", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  // Peer (the other user)
  peer User @relation("ChatThreadReadPeer", fields: [peerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([workspaceUid, userId, peerId])
  @@index([workspaceUid, userId])
  @@index([workspaceUid, userId, updatedAt])
}

model UserStatus {
  userId          BigInt         @id
  status          PresenceStatus @default(AVAILABLE)
  currentActivity String?        @db.VarChar(255)
  updatedAt       DateTime       @default(now()) @updatedAt
  
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([status])
  @@index([updatedAt(sort: Desc)])
  //@@map("public.UserStatus")
}

model UserPresence {
  id           BigInt         @id @default(autoincrement())
  userId       BigInt
  workspaceUid String
  status       PresenceStatus @default(AVAILABLE)
  isOnline     Boolean        @default(false)
  lastActivity DateTime       @default(now())
  deviceInfo   Json?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace    Workspace      @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade)
  
  @@unique([userId, workspaceUid])
  @@index([workspaceUid, isOnline])
  @@index([userId])
  @@index([lastActivity(sort: Desc)])
  //@@map("public.UserPresence")
}

model UserWorkspaceSession {
  id            BigInt    @id @default(autoincrement())
  userId        BigInt
  workspaceUid  String
  sessionStart  DateTime  @default(now())
  sessionEnd    DateTime?
  duration      Int?
  statusChanges Json      @default("[]")
  activities    Json      @default("[]")
  deviceInfo    Json?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace     Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade)
  
  @@index([userId, sessionStart(sort: Desc)])
  @@index([workspaceUid, sessionStart(sort: Desc)])
  @@index([sessionEnd])
  //@@map("public.UserWorkspaceSession")
}