// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthProvider {
  local
  google
  microsoft
}

model User {
  id          BigInt  @id @default(autoincrement())
  first_name  String  @db.VarChar(100)
  last_name   String  @db.VarChar(100)
  displayName String? @db.VarChar(120)

  // canonical email (case-insensitive at DB level with CITEXT)
  email           String    @unique @db.Citext
  emailVerifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  identities        AuthIdentity[]
  credential        UserLogin?
  workspacesCreated Workspace[]       @relation("UserCreatedWorkspaces")
  memberships       WorkspaceMember[]
  invitesSent       Invitation[]      @relation("UserInvites")

  // Chat relations (named -> must have both sides!)
  chatMessages     ChatMessage[] @relation("ChatMessageSender") // messages I sent
  receivedMessages ChatMessage[] @relation("ChatMessageRecipient") // messages I received (DMs)

  // Thread read relations (named -> must have both sides!)
  chatThreadRead   ChatThreadRead[] @relation("ChatThreadReadReader") // I'm the reader
  chatThreadAsPeer ChatThreadRead[] @relation("ChatThreadReadPeer") // I'm the peer being read

  @@index([email])
}

model AuthIdentity {
  id          BigInt       @id @default(autoincrement())
  userId      BigInt
  provider    AuthProvider
  providerId  String // email for local login and sub for google/microsoft
  createdAt   DateTime     @default(now())
  lastLoginAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([provider, providerId])
  @@index([userId, provider])
}

model UserLogin {
  userId    BigInt   @id
  hash      String   @db.VarChar(255)
  alg       String   @default("argon2id")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
}

model Workspace {
  uid       String   @id @default(cuid())
  name      String   @db.VarChar(120)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById BigInt
  createdBy   User   @relation("UserCreatedWorkspaces", fields: [createdById], references: [id], onDelete: Restrict, onUpdate: Cascade)

  members        WorkspaceMember[]
  invitations    Invitation[]
  chatMessages   ChatMessage[]
  chatThreadRead ChatThreadRead[]

  @@index([createdById])
}

model WorkspaceMember {
  workspaceUid String
  userId       BigInt

  role     WorkspaceRole @default(MEMBER)
  joinedAt DateTime      @default(now())

  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([workspaceUid, userId])
  @@index([userId])
  @@index([workspaceUid, role])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REVOKED
  EXPIRED
}

model Invitation {
  id           String           @id @default(uuid()) @db.Uuid
  workspaceUid String
  invitedBy    BigInt
  invitedEmail String           @db.Citext
  role         WorkspaceRole    @default(MEMBER)
  expiresAt    DateTime
  status       InvitationStatus @default(PENDING)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)
  inviter   User      @relation("UserInvites", fields: [invitedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([workspaceUid])
  @@index([invitedEmail])
}

// Email templates
model EmailTemplate {
  id        String   @id @default(uuid())
  name      String   @unique
  subject   String
  mailBody  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Chat messages (per workspace/room)
model ChatMessage {
  id           BigInt    @id @default(autoincrement())
  workspaceUid String
  senderId     BigInt
  /// when set, message is a private DM visible only to sender and this recipient
  recipientId  BigInt?
  /// LiveKit room id (can equal Workspace.uid)
  roomUid      String
  content      String
  createdAt    DateTime  @default(now())
  deletedAt    DateTime?

  // relations
  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)
  sender    User      @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  recipient User?     @relation("ChatMessageRecipient", fields: [recipientId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // indexes tuned for unread counts + typical inbox queries
  @@index([workspaceUid, createdAt])
  @@index([senderId, createdAt])
  @@index([workspaceUid, recipientId, createdAt]) // fetch my DMs by recency
  @@index([workspaceUid, recipientId, senderId, createdAt]) // unread groupBy(senderId) with cutoff
  @@index([workspaceUid, senderId, deletedAt]) // soft-deletion-aware scans
}

// Per-user DM read state for each peer inside a workspace
model ChatThreadRead {
  workspaceUid String
  userId       BigInt
  peerId       BigInt
  lastReadAt   DateTime @default(now())
  updatedAt    DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceUid], references: [uid], onDelete: Cascade, onUpdate: Cascade)

  // Reader (me)
  user User @relation("ChatThreadReadReader", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  // Peer (the other user)
  peer User @relation("ChatThreadReadPeer", fields: [peerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([workspaceUid, userId, peerId])
  @@index([workspaceUid, userId])
  @@index([workspaceUid, userId, updatedAt])
}
